<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>알림창</title>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <style>
    @font-face {
      font-family: 'NanumSquareRound';
      font-weight: 300;
      src: url('../font/NanumSquareRoundL.ttf') format('truetype');
    }
    @font-face {
      font-family: 'NanumSquareRound';
      font-weight: 400;
      src: url('../font/NanumSquareRoundR.ttf') format('truetype');
    }
    @font-face {
      font-family: 'NanumSquareRound';
      font-weight: 700;
      src: url('../font/NanumSquareRoundB.ttf') format('truetype');
    }
    @font-face {
      font-family: 'NanumSquareRound';
      font-weight: 800;
      src: url('../font/NanumSquareRoundEB.ttf') format('truetype');
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'NanumSquareRound', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: transparent;
      height: 100vh;
      overflow: hidden;
      -webkit-app-region: no-drag;
      margin: 0;
      padding: 0;
      position: relative;
    }

    html {
      background: transparent;
      overflow: hidden;
    }

    /* 그림자 레이어 */
    .shadow-layer {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: transparent;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4),
                  0 2px 8px rgba(0, 0, 0, 0.2);
      pointer-events: none;
      z-index: 0;
    }

    /* 전체 창 래퍼 */
    .window-wrapper {
      overflow: hidden;
      position: relative;
      z-index: 1;
      background: white;
    }

    /* 커스텀 타이틀바 */
    .custom-titlebar {
      height: 40px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 12px;
      -webkit-app-region: drag;
    }

    .titlebar-title {
      color: white;
      font-size: 0.9375rem;
      font-weight: 700;
    }

    .titlebar-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      -webkit-app-region: no-drag;
    }

    .opacity-slider-container {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .opacity-slider-label {
      color: white;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .opacity-slider {
      width: 80px;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }

    .opacity-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: white;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .opacity-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: white;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .titlebar-buttons {
      display: flex;
      gap: 8px;
    }

    .titlebar-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      transition: all 0.2s;
    }

    .titlebar-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .titlebar-btn.close:hover {
      background: #ef4444;
    }

    /* 컨테이너 */
    .sticky-container {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: #f8f9fa;
    }

    .sticky-content {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* 섹션 스타일 */
    .section {
      background: white;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      border-bottom: 1px solid #e5e7eb;
      flex-shrink: 0;
    }

    /* 팀 메모, 미처리 상담 요청, 오늘 일정 - 내용만큼만 차지 */
    #memoSection,
    #pendingSection,
    #scheduleSection {
      flex: 0 0 auto;
    }

    .section-header {
      padding: 0.625rem 0.75rem;
      background: linear-gradient(135deg, #f5f7fa 0%, #e8eef5 100%);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #e5e7eb;
      flex-shrink: 0;
    }

    .section-title {
      font-size: 0.875rem;
      font-weight: 700;
      color: #1a1a1a;
      display: flex;
      align-items: center;
      gap: 0.375rem;
    }

    .section-count {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 0.6875rem;
      font-weight: 700;
      padding: 0.125rem 0.5rem;
      border-radius: 12px;
      min-width: 20px;
      text-align: center;
    }

    .section-body {
      overflow-y: auto;
      min-height: 0;
    }

    /* 팀 메모 body - 내용만큼 차지, 넘으면 스크롤 */
    #memoBody {
      max-height: 300px;
    }

    /* 미처리 상담 요청 body */
    #pendingBody {
      max-height: 150px;
    }

    /* 오늘 일정 body - 3개 정도 높이까지, 넘으면 스크롤 */
    #scheduleBody {
      max-height: 180px;
    }

    /* 미처리 상담 요약 바 */
    .pending-summary-bar {
      display: flex;
      gap: 0.5rem;
      padding: 0.625rem 0.75rem;
      background: white;
      border-top: 1px solid #e5e7eb;
      flex-shrink: 0;
    }

    .pending-item-compact {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 0.75rem;
      background: linear-gradient(135deg, #f5f7fa 0%, #e8eef5 100%);
      border-radius: 6px;
      border: 1px solid #e5e7eb;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .pending-item-compact:hover {
      background: linear-gradient(135deg, #e8eef5 0%, #dce4f0 100%);
      border-color: #667eea;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
    }

    .pending-label {
      font-size: 0.8125rem;
      font-weight: 600;
      color: #666;
    }

    .pending-count {
      font-size: 1.125rem;
      font-weight: 800;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* 메모 아이템 */
    .memo-item {
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid #f1f3f5;
      cursor: pointer;
      transition: background 0.2s;
    }

    .memo-item:last-child {
      border-bottom: none;
    }

    .memo-item:hover {
      background: #f8f9fa;
    }

    .memo-header {
      display: flex;
      align-items: center;
      gap: 0.375rem;
    }

    .memo-badge {
      font-size: 0.5625rem;
      padding: 0.125rem 0.375rem;
      border-radius: 3px;
      font-weight: 700;
      background: #ef4444;
      color: white;
    }

    .memo-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: #1a1a1a;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .memo-content {
      font-size: 0.6875rem;
      color: #666;
      line-height: 1.3;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .memo-author {
      font-size: 0.625rem;
      color: #999;
      font-weight: 600;
      margin-left: auto;
      flex-shrink: 0;
    }

    /* 일정 카테고리 */
    .schedule-category {
      border-bottom: 1px solid #f1f3f5;
    }

    .schedule-category:last-child {
      border-bottom: none;
    }

    .schedule-category-title {
      font-size: 0.6875rem;
      font-weight: 700;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid #e5e7eb;
    }

    .schedule-category.company .schedule-category-title {
      color: #667eea;
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    }

    .schedule-category.personal .schedule-category-title {
      color: #10b981;
      background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
    }

    /* 일정 아이템 */
    .schedule-item {
      padding: 0.4rem 0.75rem;
      border-bottom: 1px solid #f1f3f5;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .schedule-item:last-child {
      border-bottom: none;
    }

    .schedule-category.company .schedule-item {
      background: #f0f7ff;
    }

    .schedule-category.personal .schedule-item {
      background: #f0fdf4;
    }

    .schedule-time {
      font-size: 0.6875rem;
      font-weight: 600;
      min-width: 60px;
    }

    .schedule-category.company .schedule-time {
      color: #667eea;
    }

    .schedule-category.personal .schedule-time {
      color: #10b981;
    }

    .schedule-name {
      font-size: 0.875rem;
      font-weight: 600;
      color: #1a1a1a;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* 미처리 상담 아이템 */
    .pending-item {
      padding: 0.625rem 0.75rem;
      border-bottom: 1px solid #f1f3f5;
      cursor: pointer;
      transition: background 0.2s;
    }

    .pending-item:last-child {
      border-bottom: none;
    }

    .pending-item:hover {
      background: #f8f9fa;
    }

    .pending-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.25rem;
    }

    .pending-name {
      font-size: 0.8125rem;
      font-weight: 700;
      color: #1a1a1a;
    }

    .pending-type {
      font-size: 0.625rem;
      padding: 0.125rem 0.375rem;
      border-radius: 3px;
      background: #e0f2fe;
      color: #0369a1;
      font-weight: 700;
    }

    .pending-message {
      font-size: 0.75rem;
      color: #666;
      line-height: 1.4;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-bottom: 0.25rem;
    }

    .pending-date {
      font-size: 0.625rem;
      color: #999;
    }

    .empty-state {
      text-align: center;
      padding: 0.75rem;
      color: #999;
      font-size: 0.75rem;
    }

    /* 스크롤바 */
    .section-body::-webkit-scrollbar {
      width: 6px;
    }

    .section-body::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 3px;
      margin: 4px 0;
    }

    .section-body::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 3px;
      transition: all 0.2s;
    }

    .section-body::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
      box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
    }

    /* 메모 추가 버튼 */
    .add-memo-btn {
      padding: 0.375rem 0.75rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .add-memo-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
    }

    /* 모달 스타일 */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
    }

    .modal-content {
      position: relative;
      background: white;
      border-radius: 12px;
      padding: 0;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      z-index: 10000;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.25rem;
      border-bottom: 1px solid #e5e7eb;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      color: #1a1a1a;
    }

    .modal-close-btn {
      background: none;
      border: none;
      font-size: 1.25rem;
      color: #999;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .modal-close-btn:hover {
      background: #f5f5f5;
      color: #333;
    }

    .modal-body {
      padding: 1.25rem;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group:last-child {
      margin-bottom: 0;
    }

    .form-group label {
      display: block;
      font-size: 0.8125rem;
      font-weight: 600;
      color: #333;
      margin-bottom: 0.5rem;
    }

    .form-group input[type="text"],
    .form-group textarea {
      width: 100%;
      padding: 0.625rem;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: 0.8125rem;
      font-family: 'NanumSquareRound', sans-serif;
      transition: all 0.2s;
      box-sizing: border-box;
    }

    .form-group input[type="text"]:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .form-group textarea {
      resize: vertical;
      min-height: 80px;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      font-weight: 400 !important;
    }

    .checkbox-label input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .modal-actions {
      display: flex;
      gap: 0.75rem;
      padding: 1rem 1.25rem;
      border-top: 1px solid #e5e7eb;
    }

    .modal-btn {
      flex: 1;
      padding: 0.625rem 1rem;
      border: none;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal-btn.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .modal-btn.primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .modal-btn.secondary {
      background: #f5f5f5;
      color: #666;
    }

    .modal-btn.secondary:hover {
      background: #e5e5e5;
    }

    /* 메모 상세보기 스타일 */
    .detail-section {
      margin-bottom: 1.25rem;
    }

    .detail-label {
      font-size: 0.8125rem;
      font-weight: 600;
      color: #333;
      margin-bottom: 0.5rem;
    }

    .detail-content {
      padding: 0.75rem;
      background: #f9fafb;
      border-radius: 6px;
      font-size: 0.875rem;
      line-height: 1.6;
      color: #333;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .detail-meta {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding-top: 1rem;
      border-top: 1px solid #e5e7eb;
    }

    .detail-meta-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8125rem;
    }

    .detail-meta-label {
      color: #999;
      font-weight: 600;
    }

    .important-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.625rem;
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      color: white;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <div class="shadow-layer"></div>
  <div class="window-wrapper">
    <!-- 커스텀 타이틀바 -->
    <div class="custom-titlebar">
      <div class="titlebar-title">알림창</div>
      <div class="titlebar-controls">
        <div class="opacity-slider-container">
          <span class="opacity-slider-label">투명도</span>
          <input
            type="range"
            class="opacity-slider"
            id="opacitySlider"
            min="50"
            max="100"
            value="100"
            oninput="changeOpacity(this.value)"
          />
        </div>
        <div class="titlebar-buttons">
          <button class="titlebar-btn close" onclick="window.close()" title="닫기">✕</button>
        </div>
      </div>
    </div>

    <!-- 컨텐츠 -->
    <div class="sticky-container">
      <div class="sticky-content">
        <!-- 오늘 일정 섹션 -->
        <div class="section" id="scheduleSection">
          <div class="section-header">
            <div class="section-title">
              오늘 일정
              <span class="section-count" id="scheduleCount">0</span>
            </div>
          </div>
          <div class="section-body" id="scheduleBody">
            <!-- 일정 아이템이 여기에 렌더링됩니다 -->
          </div>
        </div>

        <!-- 미처리 상담 요청 섹션 -->
        <div class="section" id="pendingSection">
          <div class="section-header">
            <div class="section-title">
              미처리 상담 요청
              <span class="section-count" id="pendingCount">0</span>
            </div>
          </div>
        </div>

        <!-- 미처리 상담 요약 (항상 표시) -->
        <div class="pending-summary-bar">
          <div class="pending-item-compact" onclick="handleSummaryClick('email')">
            <span class="pending-label">이메일</span>
            <span class="pending-count" id="emailCount">0</span>
          </div>
          <div class="pending-item-compact" onclick="handleSummaryClick('website')">
            <span class="pending-label">홈페이지</span>
            <span class="pending-count" id="websiteCount">0</span>
          </div>
        </div>

        <!-- 팀 메모 섹션 -->
        <div class="section" id="memoSection">
          <div class="section-header">
            <div class="section-title">
              팀 메모
              <span class="section-count" id="memoCount">0</span>
            </div>
            <button class="add-memo-btn" onclick="showAddMemoModal()">+ 추가</button>
          </div>
          <div class="section-body" id="memoBody">
            <!-- 메모 아이템이 여기에 렌더링됩니다 -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 메모 추가 모달 -->
  <div id="addMemoModal" class="modal" style="display: none;">
    <div class="modal-overlay" onclick="closeAddMemoModal()"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3>메모 추가</h3>
        <button class="modal-close-btn" onclick="closeAddMemoModal()">✕</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>제목 (선택)</label>
          <input type="text" id="memoTitle" placeholder="제목을 입력하세요 (비워두면 내용 일부가 제목이 됩니다)" />
        </div>
        <div class="form-group">
          <label>내용</label>
          <textarea id="memoContent" placeholder="메모 내용을 입력하세요" rows="6" required></textarea>
        </div>
        <div class="form-group">
          <label class="checkbox-label">
            <input type="checkbox" id="memoImportant" />
            <span>중요 메모로 표시</span>
          </label>
        </div>
      </div>
      <div class="modal-actions">
        <button class="modal-btn secondary" onclick="closeAddMemoModal()">취소</button>
        <button class="modal-btn primary" onclick="saveNewMemo()">저장</button>
      </div>
    </div>
  </div>

  <!-- 메모 상세보기 모달 -->
  <div id="memoDetailModal" class="modal" style="display: none;">
    <div class="modal-overlay" onclick="closeMemoDetailModal()"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="detailTitle">메모 제목</h3>
        <button class="modal-close-btn" onclick="closeMemoDetailModal()">✕</button>
      </div>
      <div class="modal-body">
        <div class="detail-section">
          <div class="detail-label">내용</div>
          <div class="detail-content" id="detailContent"></div>
        </div>
        <div class="detail-meta">
          <div class="detail-meta-item">
            <span class="detail-meta-label">작성자:</span>
            <span id="detailAuthor">-</span>
          </div>
          <div class="detail-meta-item">
            <span class="detail-meta-label">작성일:</span>
            <span id="detailDate">-</span>
          </div>
          <div class="detail-meta-item" id="detailImportantBadge" style="display: none;">
            <span class="important-badge">⭐ 중요</span>
          </div>
        </div>
      </div>
      <div class="modal-actions">
        <button class="modal-btn secondary" onclick="closeMemoDetailModal()">닫기</button>
      </div>
    </div>
  </div>

  <script>
    // Get today's date in YYYY-MM-DD format (Korea timezone)
    function getTodayString() {
      const today = new Date();
      const year = today.getFullYear();
      const month = String(today.getMonth() + 1).padStart(2, '0');
      const day = String(today.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    // URL 자동 링크 변환 함수 - 간단보기용 (클릭 불가)
    function linkifyContentSimple(text) {
      if (!text) return '';
      const urlPattern = /(https?:\/\/[^\s]+)|(www\.[^\s]+)/g;
      const linkedText = text.replace(urlPattern, (url) => {
        return `<span class="link-text" style="color: #667eea; text-decoration: underline; cursor: default;">${url}</span>`;
      });
      return DOMPurify.sanitize(linkedText);
    }

    // 외부 링크를 기본 브라우저에서 열기 (data-clickable 속성 체크)
    document.addEventListener('click', (e) => {
      if (e.target.tagName === 'A' && e.target.dataset.clickable === 'true') {
        e.preventDefault();
        const href = e.target.getAttribute('href');
        if (window.electron && window.electron.openExternal) {
          window.electron.openExternal(href);
        }
      }
    });

    console.log('[Sticky] Script started!');

    // API 기본 URL - HTTP 요청은 릴레이 서버 프록시, WebSocket은 릴레이 서버
    const API_BASE_URL = 'http://136.113.67.193:8080/proxy'; // HTTP API 요청용
    const WEBSOCKET_URL = 'ws://136.113.67.193:8080'; // WebSocket 연결용 (메인 앱과 동일)
    console.log('[Sticky] API_BASE_URL:', API_BASE_URL);
    console.log('[Sticky] WEBSOCKET_URL:', WEBSOCKET_URL);

    // 전역 데이터
    let memos = [];
    let schedules = [];
    let stats = { website: 0, email: 0 };

    // 즉시 초기값 설정 (API 로드 전이라도 0 표시)
    window.addEventListener('load', () => {
      console.log('[Sticky] Window loaded, setting initial values...');
      const emailCount = document.getElementById('emailCount');
      const websiteCount = document.getElementById('websiteCount');
      const scheduleCount = document.getElementById('scheduleCount');
      const memoCount = document.getElementById('memoCount');

      if (emailCount) emailCount.textContent = '0';
      if (websiteCount) websiteCount.textContent = '0';
      if (scheduleCount) scheduleCount.textContent = '0';
      if (memoCount) memoCount.textContent = '0';
      console.log('[Sticky] Initial values set');
    });

    // 전역 인증 정보 캐시
    let cachedAuthData = null;

    // IPC를 통해 메인 프로세스에서 인증 정보 가져오기
    async function getAuthData() {
      if (cachedAuthData) {
        return cachedAuthData;
      }

      try {
        if (window.electron && window.electron.getAuthToken) {
          const result = await window.electron.getAuthToken();
          if (result.success) {
            cachedAuthData = result.user;
            console.log('[Sticky] Auth data loaded from main process:', cachedAuthData.email);
            return cachedAuthData;
          } else {
            console.error('[Sticky] Failed to get auth token:', result.error);
            return null;
          }
        } else {
          console.error('[Sticky] Electron API not available');
          return null;
        }
      } catch (error) {
        console.error('[Sticky] Failed to get auth data:', error);
        return null;
      }
    }

    // 로컬 스토리지에서 인증 정보 가져오기 (폴백)
    async function getAuthToken() {
      const authData = await getAuthData();
      return authData ? authData.idToken : null;
    }

    async function getUserProvider() {
      const authData = await getAuthData();
      return authData ? authData.provider : null;
    }

    // API 호출 헬퍼
    async function apiRequest(endpoint, options = {}) {
      const token = await getAuthToken();
      const provider = await getUserProvider();

      if (!token) {
        throw new Error('인증 토큰이 없습니다.');
      }

      const headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
        'X-Provider': provider,
        ...options.headers,
      };

      const response = await fetch(`${API_BASE_URL}${endpoint}`, {
        ...options,
        headers,
      });

      if (!response.ok) {
        throw new Error(`API 요청 실패: ${response.status}`);
      }

      return response.json();
    }

    // 메모 목록 불러오기
    async function loadMemos() {
      try {
        console.log('[Sticky] Loading memos from API...');
        const response = await apiRequest('/memos');
        console.log('[Sticky] Memos API response:', response);
        memos = response.data || [];
        console.log('[Sticky] Parsed memos:', memos.length);
        renderMemos();
      } catch (error) {
        console.error('[Sticky] 메모 불러오기 실패:', error);
        memos = [];
        renderMemos();
      }
    }

    // 상담 통계 불러오기
    async function loadConsultationStats() {
      try {
        console.log('[Sticky] Loading consultation stats from API...');

        // 홈페이지 통계
        const websiteResponse = await apiRequest('/inquiries/stats');
        console.log('[Sticky] Website stats API response:', websiteResponse);

        // 이메일 통계
        const emailResponse = await apiRequest('/email-inquiries/stats');
        console.log('[Sticky] Email stats API response:', emailResponse);

        stats = {
          website: websiteResponse.data?.website || 0,
          email: emailResponse.data?.unread || 0,  // 미확인 수량
        };

        console.log('[Sticky] Parsed stats:', stats);
        updateConsultationStats();
      } catch (error) {
        console.error('[Sticky] 통계 불러오기 실패:', error);
        stats = { website: 0, email: 0 };
        updateConsultationStats();
      }
    }


    // 일정 목록 불러오기
    async function loadSchedules() {
      try {
        console.log('[Sticky] Loading schedules from API...');
        const response = await apiRequest('/schedules');
        console.log('[Sticky] Schedules API response:', response);
        schedules = response.data || [];
        console.log('[Sticky] Parsed schedules:', schedules.length);
        renderSchedules();
      } catch (error) {
        console.error('[Sticky] 일정 불러오기 실패:', error);
        schedules = [];
        renderSchedules();
      }
    }

    function updateConsultationStats() {
      // stats API에서 받아온 통계 사용
      const emailCount = stats.email || 0;
      const websiteCount = stats.website || 0;
      const totalPending = emailCount + websiteCount;

      console.log('[Sticky] Updating stats display:', { emailCount, websiteCount, totalPending });

      document.getElementById('emailCount').textContent = emailCount;
      document.getElementById('websiteCount').textContent = websiteCount;
      document.getElementById('pendingCount').textContent = totalPending;

      // 높이 재조정
      adjustWindowHeight();
    }

    // 요약 바 클릭 시 메인 창 열기 및 해당 상담 탭으로 이동
    async function handleSummaryClick(type) {
      if (window.electron && window.electron.focusMainWindow) {
        try {
          // 메인 창을 포커스하고 해당 상담 유형 경로로 이동
          const route = `/consultations/${type}`;
          await window.electron.focusMainWindow(route);
          console.log(`[Sticky] Main window focused, navigated to ${route}`);
        } catch (error) {
          console.error('[Sticky] Failed to focus main window:', error);
        }
      }
    }



    // 일정 렌더링 함수
    function renderSchedules() {
      const todayString = getTodayString();
      console.log('[Sticky] renderSchedules called, today:', todayString, 'schedules:', schedules.length);

      const todaySchedules = schedules.filter(s => {
        if (!s.start_date) return false;
        const startDate = s.start_date.split('T')[0];
        const endDate = s.end_date ? s.end_date.split('T')[0] : startDate;
        return todayString >= startDate && todayString <= endDate;
      });

      console.log('[Sticky] Today schedules:', todaySchedules.length);

      // 일정 카운트 업데이트
      const scheduleCountEl = document.getElementById('scheduleCount');
      if (scheduleCountEl) scheduleCountEl.textContent = todaySchedules.length;

      // 회사/개인 분류
      const companySchedules = todaySchedules.filter(s => s.type === '회사' || s.type === 'company');
      const personalSchedules = todaySchedules.filter(s => s.type === '개인' || s.type === 'personal');

      const scheduleBody = document.getElementById('scheduleBody');
      if (!scheduleBody) {
        console.error('[Sticky] scheduleBody element not found!');
        return;
      }

      if (todaySchedules.length === 0) {
        scheduleBody.innerHTML = '<div class="empty-state">오늘 일정이 없습니다</div>';
      } else {
        let scheduleHTML = '';

        // 회사 일정
        if (companySchedules.length > 0) {
          scheduleHTML += `
            <div class="schedule-category company">
              <div class="schedule-category-title">회사</div>
          `;
          companySchedules.forEach(schedule => {
            const time = schedule.time || '시간 미정';
            scheduleHTML += `
              <div class="schedule-item">
                <span class="schedule-time">${time}</span>
                <span class="schedule-name">${schedule.title}</span>
              </div>
            `;
          });
          scheduleHTML += '</div>';
        }

        // 개인 일정
        if (personalSchedules.length > 0) {
          scheduleHTML += `
            <div class="schedule-category personal">
              <div class="schedule-category-title">개인</div>
          `;
          personalSchedules.forEach(schedule => {
            const time = schedule.time || '시간 미정';
            const authorName = schedule.author_name || schedule.author || '';
            const displayTitle = authorName ? `${authorName} - ${schedule.title}` : schedule.title;
            scheduleHTML += `
              <div class="schedule-item">
                <span class="schedule-time">${time}</span>
                <span class="schedule-name">${displayTitle}</span>
              </div>
            `;
          });
          scheduleHTML += '</div>';
        }

        scheduleBody.innerHTML = scheduleHTML;
      }
      console.log('[Sticky] Schedules rendered successfully');

      // 높이 재조정
      adjustWindowHeight();
    }

    // 메모 렌더링 함수 (재사용 가능하도록 분리)
    function renderMemos() {
      console.log('[Sticky] renderMemos() called, memos count:', memos.length);
      const memoBody = document.getElementById('memoBody');
      const memoCount = document.getElementById('memoCount');

      if (!memoBody) {
        console.error('[Sticky] memoBody element not found!');
        return;
      }
      if (!memoCount) {
        console.error('[Sticky] memoCount element not found!');
        return;
      }

      // 만료되지 않은 메모만 필터링 (Dashboard.jsx lines 493-499와 동일한 로직)
      const validMemos = memos.filter(memo => {
        if (!memo.expire_date) return true; // 만료일 없으면 항상 표시
        const expireDate = new Date(memo.expire_date);
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        return expireDate >= today;
      });

      memoCount.textContent = validMemos.length;

      if (validMemos.length === 0) {
        memoBody.innerHTML = '<div class="empty-state">메모가 없습니다</div>';
      } else {
        memoBody.innerHTML = validMemos.map((memo) => `
          <div class="memo-item" onclick="showMemoDetail(${memo.id})" style="cursor: pointer;">
            <div class="memo-header">
              ${memo.important ? '<span class="memo-badge">중요</span>' : ''}
              <div class="memo-title">${memo.title}</div>
              ${memo.author ? `<div class="memo-author">${memo.author_name || memo.author || '사용자'}</div>` : ''}
            </div>
            <div class="memo-content">${linkifyContentSimple(memo.content)}</div>
          </div>
        `).join('');
      }
      console.log('[Sticky] Memos rendered successfully, valid memos:', validMemos.length);

      // 높이 재조정
      adjustWindowHeight();
    }

    // 서브 윈도우 방식으로 변경
    async function showAddMemoModal() {
      if (window.electron && window.electron.openMemoSubWindow) {
        try {
          await window.electron.openMemoSubWindow('create');
        } catch (error) {
          console.error('[Sticky] 메모 추가 창 열기 실패:', error);
          alert('메모 추가 창을 열 수 없습니다.');
        }
      } else {
        console.error('[Sticky] Electron API가 없습니다.');
        alert('메모 추가 기능을 사용할 수 없습니다.');
      }
    }

    async function showMemoDetail(memoId) {
      if (window.electron && window.electron.openMemoSubWindow) {
        try {
          await window.electron.openMemoSubWindow('view', memoId);
        } catch (error) {
          console.error('[Sticky] 메모 상세보기 창 열기 실패:', error);
          alert('메모 상세보기 창을 열 수 없습니다.');
        }
      } else {
        console.error('[Sticky] Electron API가 없습니다.');
        alert('메모 상세보기 기능을 사용할 수 없습니다.');
      }
    }

    // 이전 모달 관련 함수들 (서브 윈도우 방식으로 변경되어 사용하지 않지만, HTML에서 참조되므로 빈 함수로 유지)
    function closeAddMemoModal() {
      // 서브 윈도우 방식으로 변경됨 - 빈 함수
    }

    async function saveNewMemo() {
      // 서브 윈도우 방식으로 변경됨 - 빈 함수
    }

    function closeMemoDetailModal() {
      // 서브 윈도우 방식으로 변경됨 - 빈 함수
    }

    // ESC 키로 모달 닫기
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        const addModal = document.getElementById('addMemoModal');
        const detailModal = document.getElementById('memoDetailModal');

        if (addModal && addModal.style.display === 'flex') {
          closeAddMemoModal();
        }
        if (detailModal && detailModal.style.display === 'flex') {
          closeMemoDetailModal();
        }
      }
    });

    // IPC 이벤트 리스너 제거 - WebSocket으로 통합
    // 메모 생성/삭제 이벤트는 WebSocket을 통해서만 처리

    // 투명도 변경 함수
    function changeOpacity(value) {
      const opacity = value / 100; // 50-100 -> 0.5-1.0
      if (window.electron && window.electron.setWindowOpacity) {
        window.electron.setWindowOpacity(opacity);
      }
    }

    // 페이지 로드 시 저장된 투명도 값으로 슬라이더 초기화
    async function initializeOpacitySlider() {
      if (window.electron && window.electron.getWindowOpacity) {
        try {
          const currentOpacity = await window.electron.getWindowOpacity();
          const sliderValue = Math.round(currentOpacity * 100);
          const slider = document.getElementById('opacitySlider');
          if (slider) {
            slider.value = sliderValue;
            console.log('[Sticky] Opacity slider initialized:', sliderValue);
          }
        } catch (error) {
          console.error('[Sticky] Failed to get window opacity:', error);
        }
      }
    }

    // IPC 이벤트 리스너: 다른 창에서 상담/일정 생성/수정/삭제 시 자동 업데이트
    if (window.electron && window.electron.onConsultationUpdated) {
      window.electron.onConsultationUpdated(async () => {
        console.log('[Sticky] 상담/일정 업데이트 이벤트 수신');
        // 상담 통계, 일정 목록 다시 불러오기
        await Promise.all([
          loadConsultationStats(),
          loadSchedules()
        ]);
      });
    }

    // WebSocket 연결 및 이벤트 리스너
    let socket = null;
    let isConnecting = false;
    let heartbeatInterval = null;
    let reconnectInterval = null;
    const RECONNECT_CHECK_INTERVAL = 30000; // 30초마다 재연결 체크

    async function connectWebSocket() {
      const authData = await getAuthData();
      if (!authData) {
        console.warn('[Sticky WebSocket] No auth data found, cannot connect');
        return null;
      }

      if (socket?.connected) {
        console.log('[Sticky WebSocket] Already connected');
        return socket;
      }

      if (isConnecting) {
        console.log('[Sticky WebSocket] Already attempting to connect, skipping...');
        return socket;
      }

      isConnecting = true;

      try {
        const token = authData.idToken;
        const provider = authData.provider;

        if (!token) {
          console.warn('[Sticky WebSocket] No token found');
          isConnecting = false;
          return null;
        }

        console.log('[Sticky WebSocket] Connecting to', WEBSOCKET_URL);

        // 기존 소켓이 있으면 정리
        if (socket) {
          socket.removeAllListeners();
          socket.disconnect();
          socket = null;
        }

        socket = io(WEBSOCKET_URL, {
          transports: ['websocket', 'polling'],
          reconnectionDelay: 1000,
          reconnection: false, // Socket.IO 자동 재연결 비활성화 (수동 관리)
          timeout: 10000
        });

        socket.on('connect', () => {
          console.log('[Sticky WebSocket] Connected to server');
          isConnecting = false;

          // Send handshake (메인 앱과 동일)
          socket.emit('handshake', {
            type: 'client',
            metadata: {
              email: authData.email,
              provider: authData.provider,
              displayName: authData.displayName,
              connectedAt: new Date().toISOString()
            }
          });
        });

        socket.on('handshake:success', (data) => {
          console.log('[Sticky WebSocket] Handshake successful:', data);
        });

        socket.on('disconnect', (reason) => {
          console.log('[Sticky WebSocket] Disconnected from server:', reason);
        });

        socket.on('connect_error', (error) => {
          console.error('[Sticky WebSocket] Connection error:', error.message);
          isConnecting = false;
        });

        // Heartbeat (30초마다 전송)
        if (heartbeatInterval) {
          clearInterval(heartbeatInterval);
        }
        heartbeatInterval = setInterval(() => {
          if (socket && socket.connected) {
            socket.emit('heartbeat');
          } else {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
          }
        }, 30000);

        // 신규 상담 생성 이벤트
        socket.on('consultation:created', () => {
          console.log('[Sticky WebSocket] New consultation created');
          loadConsultationStats();
        });

        // 상담 업데이트 이벤트
        socket.on('consultation:updated', () => {
          console.log('[Sticky WebSocket] Consultation updated');
          loadConsultationStats();
        });

        // 상담 삭제 이벤트
        socket.on('consultation:deleted', () => {
          console.log('[Sticky WebSocket] Consultation deleted');
          loadConsultationStats();
        });

        // 이메일 생성 이벤트
        socket.on('email:created', (newEmail) => {
          console.log('[Sticky WebSocket] Email created:', newEmail);
          loadConsultationStats();
        });

        // 이메일 업데이트 이벤트
        socket.on('email:updated', (data) => {
          console.log('[Sticky WebSocket] Email updated:', data.id);
          loadConsultationStats();
        });

        // 이메일 삭제 이벤트
        socket.on('email:deleted', (data) => {
          console.log('[Sticky WebSocket] Email deleted:', data.id);
          loadConsultationStats();
        });

        // 메모 생성 이벤트
        socket.on('memo:created', (newMemo) => {
          console.log('[Sticky WebSocket] Memo created:', newMemo);
          loadMemos();
        });

        // 메모 삭제 이벤트
        socket.on('memo:deleted', (data) => {
          console.log('[Sticky WebSocket] Memo deleted:', data.id);
          loadMemos();
        });

        // 일정 생성 이벤트
        socket.on('schedule:created', (newSchedule) => {
          console.log('[Sticky WebSocket] Schedule created:', newSchedule);
          loadSchedules();
        });

        // 일정 수정 이벤트
        socket.on('schedule:updated', (data) => {
          console.log('[Sticky WebSocket] Schedule updated:', data);
          loadSchedules();
        });

        // 일정 삭제 이벤트
        socket.on('schedule:deleted', (data) => {
          console.log('[Sticky WebSocket] Schedule deleted:', data.id);
          loadSchedules();
        });

        // 재연결 시 데이터 동기화
        socket.on('connect', async () => {
          console.log('[Sticky WebSocket] Connected, reloading data...');
          try {
            await Promise.all([
              loadMemos(),
              loadConsultationStats(),
              loadSchedules()
            ]);
          } catch (error) {
            console.error('[Sticky WebSocket] Failed to reload data on reconnect:', error);
          }
        });

        // 주기적인 재연결 체크 시작
        startReconnectMonitor();

        return socket;
      } catch (error) {
        console.error('[Sticky WebSocket] Failed to connect:', error);
        isConnecting = false;
        return null;
      }
    }

    /**
     * 주기적으로 연결 상태 확인 및 재연결
     */
    function startReconnectMonitor() {
      // 기존 인터벌이 있으면 정리
      if (reconnectInterval) {
        clearInterval(reconnectInterval);
      }

      reconnectInterval = setInterval(async () => {
        const authData = await getAuthData();

        if (!authData) {
          console.log('[Sticky WebSocket] No auth data, skipping reconnect check');
          return;
        }

        if (!socket || !socket.connected) {
          console.log('[Sticky WebSocket] Connection lost, attempting to reconnect...');
          connectWebSocket();
        }
      }, RECONNECT_CHECK_INTERVAL);
    }

    /**
     * WebSocket 연결 종료 (창 닫을 때 호출)
     */
    function disconnectWebSocket() {
      // 재연결 모니터 중지
      if (reconnectInterval) {
        clearInterval(reconnectInterval);
        reconnectInterval = null;
      }

      // Heartbeat 중지
      if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
      }

      if (socket) {
        console.log('[Sticky WebSocket] Disconnecting...');
        socket.removeAllListeners();
        socket.disconnect();
        socket = null;
      }

      isConnecting = false;
    }

    // 창 닫힐 때 정리
    window.addEventListener('beforeunload', () => {
      disconnectWebSocket();
    });

    // 초기 데이터 수신 및 렌더링
    function initializeWithCachedData(cachedData) {
      console.log('[Sticky] Initializing with cached data:', cachedData);

      // 메모 초기화
      if (cachedData.memos && Array.isArray(cachedData.memos)) {
        memos = cachedData.memos;
        renderMemos();
        console.log('[Sticky] Rendered cached memos:', memos.length);
      }

      // 일정 초기화
      if (cachedData.schedules && Array.isArray(cachedData.schedules)) {
        schedules = cachedData.schedules;
        renderSchedules();
        console.log('[Sticky] Rendered cached schedules:', schedules.length);
      }

      // 상담 통계 초기화
      if (cachedData.consultations && Array.isArray(cachedData.consultations)) {
        stats = {
          website: cachedData.consultations.filter(c => c.type === 'website' && !c.check).length,
          email: cachedData.consultations.filter(c => c.type === 'email' && !c.check).length
        };
        renderConsultationStats();
        console.log('[Sticky] Rendered cached consultation stats:', stats);
      }

      // 캐시 데이터 렌더링 후 높이 조정
      adjustWindowHeight();
    }

    // 페이지 로드 시 데이터 초기화
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('[Sticky] Initializing data...');
      console.log('[Sticky] Checking auth data via IPC...');

      // 투명도 슬라이더 초기화
      await initializeOpacitySlider();

      const authData = await getAuthData();
      console.log('[Sticky] Auth data from IPC:', authData ? 'Found' : 'NOT FOUND');

      if (!authData) {
        console.error('[Sticky] No auth token found!');
        document.getElementById('memoBody').innerHTML = '<div class="empty-state">인증 정보가 없습니다. 메인 창에서 로그인해주세요.</div>';
        document.getElementById('scheduleBody').innerHTML = '<div class="empty-state">인증 정보가 없습니다.</div>';
        return;
      }

      // URL 파라미터에서 전달받은 캐시 데이터 확인
      const urlParams = new URLSearchParams(window.location.search);
      const cachedDataParam = urlParams.get('cachedData');

      if (cachedDataParam) {
        try {
          // URLSearchParams.get()은 자동으로 디코딩하므로 decodeURIComponent 불필요
          const cachedData = JSON.parse(cachedDataParam);
          console.log('[Sticky] Found cached data in URL params');
          initializeWithCachedData(cachedData);
        } catch (error) {
          console.error('[Sticky] Failed to parse cached data:', error);
        }
      }

      // 백그라운드에서 API로 최신 데이터 가져오기
      try {
        console.log('[Sticky] Fetching fresh data from API in background...');
        await Promise.all([
          loadMemos(),
          loadConsultationStats(),
          loadSchedules()
        ]);
        console.log('[Sticky] Fresh data loaded:', { memos: memos.length, schedules: schedules.length, stats });

        // 내용 업데이트 후 윈도우 높이 재조정
        adjustWindowHeight();

        // WebSocket 연결
        connectWebSocket();
      } catch (error) {
        console.error('[Sticky] Failed to load fresh data:', error);
      }
    });

    // 윈도우 높이 자동 조정 함수
    function adjustWindowHeight() {
      // 약간의 지연을 두고 실행 (렌더링 완료 대기)
      setTimeout(async () => {
        const container = document.querySelector('.sticky-container');
        if (container && window.electron && window.electron.resizeStickyWindow) {
          const contentHeight = container.scrollHeight;
          const totalHeight = contentHeight + 40; // 타이틀바 40px 추가

          console.log('[Sticky] Adjusting window height:', totalHeight);
          await window.electron.resizeStickyWindow(300, totalHeight);

          // 크기 조정 후 윈도우 표시
          if (window.electron.showStickyWindow) {
            await window.electron.showStickyWindow();
            console.log('[Sticky] Window shown');
          }
        }
      }, 100);
    }
  </script>
</body>
</html>
